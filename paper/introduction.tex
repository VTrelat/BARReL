\section{Introduction}

The B method~\cite{Bmethod} and its associated toolsets, notably Atelier~B \cite{AtelierB}, have been used for decades in industrial developments where strong assurance arguments are required.
B specifications are written as \emph{machines} with sets, constants, variables, invariants and operations; Atelier~B generates proof obligations (PO) that guarantee, for example, invariant preservation and refinement correctness, and ships with automated and interactive provers tailored to this logic.
In many certified developments, these tools are trusted as part of the verification chain.

In parallel, interactive theorem provers have seen rapid adoption, driven by their expressive type theories, powerful automation, and growing libraries of reusable mathematics and verification components.
Lean~4~\cite{lean} in particular offers a small trusted kernel, a rich standard library, and a meta-programming framework that makes it attractive both as a programming language and a proof assistant.
However, despite B’s long-standing industrial role, support for using modern interactive theorem provers as backends for Atelier~B remains very limited: some previous work targets Isabelle~\cite{IsabelleHOL} but is either no longer maintained~\cite{Schmalz2012RodinIsabelle} or provides specific support~\cite{Wolff2024EB_Isabelle} for Event-B~\cite{AbrialEventB}.
There were also developments in Rocq~\cite{Coq12}, focussing primarily on formalizing the semantics of B rather than providing an integrated backend~\cite{Bodeveix2002BtoPVS}, and Atelier~B’s own interactive prover is comparatively dated and lacks many modern features.

This paper presents \emph{\barrel} (B Automated tRanslation for Reasoning in Lean), a Lean~4 library that bridges Atelier~B and Lean by turning B proof obligations into Lean theorems.
Given either a B machine or a pre-generated proof obligation file, \barrel generates proof obligations (PO) if needed and translates each goal into a proper Lean theorem expressed over mathlib's set-theoretic primitives, preserving the original structures and notations as closely as possible.
The library exposes two commands, \texttt{mch\_discharger} and \texttt{pog\_discharger}, which produce a sequence of Lean goals corresponding to the PO of respectively the given machine and proof obligation file;\@ users then discharge these goals interactively with standard tactic scripts, and the resulting theorems are added to the environment under names derived from the original POG tags.
The translation pipeline is organised into clearly separated components: a lightweight embedding of B syntax, an XML POG reader, an encoding layer mapping B constructs to Lean expressions, and a discharger that generates theorem declarations and connects them to user proofs.

\info[perhaps remove from here?]
A central challenge in this setting is the use of partial B operators.
Function application, the minimum and maximum of a set, and cardinality are all only defined under suitable well-formedness (WF) conditions.
Atelier~B typically handles these via additional WF proof obligations, which are generated \emph{after} the main obligations, expecting that they will be later instantiated when needed.
Lean, on the other hand, has no built-in notion of partiality and must therefore exhibit WF conditions as explicit proof parameters of the relevant functions.
This also means that one cannot construct a term depending on a partial operator without providing a proof that it is well-formed.
From the user's perspective, the discharger presents a sequence of goals where WF obligations appear explicitly, ahead of the original PO, and all of them can be proved using the usual tactic language and existing library lemmas.

The implementation is written entirely inside Lean, using its elaboration and meta-programming facilities rather than a standalone translator, making it modular.
The B fragment currently supported already covers many industrially relevant obligations.
Extending this fragment---for example, to handle strings or real numbers---typically requires only adding new syntax constructors and encoding clauses in the existing framework.
Finally, \barrel opens the door to using Lean as an independent backend in B-based workflows and suggests interesting extensions, such as an integrated proof obligation generator which can even be verified.
We do not discuss semantics or soundness of the encoding in this paper.

The rest of this paper is organised as follows.\todo[Check structure]
We first recall the necessary background on the B method, proof obligations, and the Lean~4 metaprogramming framework.
We then present the design and implementation of \barrel, detailing the encoding of B syntax, the interface with Atelier~B's proof obligation generator, and our treatment of partial operators and their well-formedness obligations.
This is followed by a case study illustrating the intended workflow on representative industrial-style machines.
We conclude with a discussion of future extensions, and position our work with respect to existing approaches to connecting B with modern interactive theorem provers.