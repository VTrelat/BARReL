\section{Contribution}

\todo[TODO]


\paragraph*{Foundations of B in Lean}

\noindent\info[Check where this belongs]
The B method is grounded in set theory: everything is expressed as a set with some added properties.
For example, functions are encoded as sets of pairs such that for every pairs $(x, y_1)$ and $(x, y_2)$ in the function $y_1 = y_2$.
However, specifications written in B are still required to satisfy some typing predicates \fixme[perhaps let's not talk about ``typing'' B?]: every constant and variable must be given a ``parent set'' they belong to.
We leverage these typing annotations and ground our encoding (mostly) in typed higher order logic instead by using Mathlib's \texttt{Set} and \texttt{SetRel} types (which are defined respectively as $\mathrm{Set}\ \alpha \triangleq \alpha \to \mathrm{Prop}$ and $\mathrm{SetRel}\ \alpha\ \beta \triangleq \mathrm{Set}(\alpha \times \beta)$) to represent sets and relations.
This still allows us to express every set used in B specifications since all sets in B are required to be homogeneous:\@ for example the set $\{0, "hi"\}$ must be considered ill-typed \fixme[ill-formed?] by implementations of the B method.

We start by defining standard B operators directly in Lean---reusing their notations from B, in order for the PO to be easily understandable by B users---and typing them appropriately in Lean to keep their use as generic as possible.
Some examples (the set of relations, the set of total injective functions and domain subtraction) are given in \cref{lst:B-sets-lean}.
%
\begin{lstlisting}[label=lst:B-sets-lean, caption={Encoding of some B operators in Lean.}]
abbrev rels {Î± Î²} (A : Set Î±) (B : Set Î²) : Set (SetRel Î± Î²) :=
  ð’« (A Ã—Ë¢ B)
scoped infixl:125 "  âŸ·  " => rels

abbrev injTFun {Î± Î²} (A : Set Î±) (B : Set Î²) : Set (SetRel Î± Î²) :=
  A â¤” B âˆ© A  âŸ¶  B
scoped infixl:125 " â†£ " => injTFun

abbrev domSubtr {Î± Î²} (E : Set Î±) (R : SetRel Î± Î²) : SetRel Î± Î² :=
{ z âˆˆ R | z.1 âˆ‰ E }
scoped infixl:160 " â©¤ " => domSubtr
\end{lstlisting}
% abbrev pfun {Î± Î²} (A : Set Î±) (B : Set Î²) : Set (SetRel Î± Î²) :=
%   { f âˆˆ A  âŸ·  B | âˆ€ â¦ƒx y zâ¦„, (x, y) âˆˆ f â†’ (x, z) âˆˆ f â†’ y = z }
% scoped infixl:125 " â‡¸ " => pfun
%
Given these definitions, we then prove various laws of B in Lean, using the infrastructure and theorems of Mathlib.
Both the definitions and theorems are readily available to end users when importing \barrel in a Lean project, and serve as basic building blocks for proofs of B obligations translated by our tool.


\paragraph*{Encoding partial B operators}

Some operators of the B language are said to be partial, meaning that they are only defined when some well-formedness (WF) conditions are satisfied.
A typical example of such an operator is the minimum operator $\bmin{S}$, which when given a set $S$ returns its smallest element, if it exists, and is undefined otherwise.
These partial operators are typically encoded using Hilbert's bounded choice operator $\epsilon\ x \in S.\ P$ which is undefined if no element of $S$ satisfy $P$.
That $P$ is satisfied by an element of $S$ is called the WF condition of the operator.

Atelier B handles this partiality by generating the WF conditions of each partial operator as side goals and assumes in the main goal that the partial operators are well-defined.
However, one must trust that these WF conditions actually correspond to the WF conditions that are expected from the context of those partial operators, and there is no clear dependency---even after inspecting the generated POG file---between the main goal and the WF side goals.

Our approach in \barrel is however quite different in that the dependency between the WF goals and the main goals is clear and explicit.
First, we do not rely on the WF conditions that are generated by Atelier B and instead generate our own to match the exact context in which they are inserted.
This is not necessarily true of the WF conditions generated by Atelier B since they undergo some simplification steps or do not match exactly our encoding of some predicates.
In practice, our tool generates WF side goals that are equivalent to the WF side goals generated by Atelier B.
%
Then, we take advantage of the dependent types of Lean to encode partial operators using \texttt{Classical.choose} (Hilbert's $\epsilon$ operator, but in Lean) which explicitly depends on a proof that the predicate is satisfied by at least one element\footnote{By doing so we encode partial operators as total functions: since they now explicitly depend on the proof of the WF condition, they cannot be undefined anymore.}.
The statement of this proof, which is the WF condition of the operator, is then generated as a side theorem which must be discharged for the main theorem to be fully proven, i.e.\@ not depend on the \texttt{sorryAx} axiom (the axiom that is introduced by admitted theorems).
In practice, our tool generates WF side goals that are equivalent to the WF side goals generated by Atelier B.