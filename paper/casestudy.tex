\section{Case study: a refinement chain for minimum search}
\label{sec:case-study}

This section evaluates \barrel on a small example with a specification and two levels of refinement, fully carried out with \barrel in Lean and compared to Atelier~B's own interactive prover.
The development computes the minimum of a non-empty finite set of integers and is progressively refined into an index-based traversal of a table,
therefore demonstrating \barrel's support for Atelier~B's refinement pipeline\footnote{Down to implementation, but this is not shown in this development.}
while correctly generating and exposing WD conditions needed for partial B operators at each level.
% Its role in this paper is \emph{not} to demonstrate Lean as a proof assistant: the proofs are largely routine and are not interesting in themselves.

The development consists of:
a specification \texttt{MinSearch.mch},
a first refinement pass \texttt{MinSearch\_r1.ref}
and a second refinement pass \texttt{MinSearch\_r2.ref},
together with a Lean script \texttt{MinSearch.lean} containing the proofs of all generated POs.
This chain exercises both data refinement and partial operators (\texttt{min}, \texttt{card}, and application), making it a compact stress-test for \barrel's WD generation and automation.

\subsection{A refinement chain: from sets to tables}

\paragraph*{Abstract specification}
The initial machine \texttt{MinSearch} shown in Listing~\ref{lst:minsearch-mch} fixes a non-empty constant subset $\texttt{S} \in \texttt{FIN1(INTEGER)}$ and maintains a set $\texttt{done}$ of already explored elements of \texttt{S} together with a candidate $\texttt{m}$ satisfying $\texttt{m} = \bmin{\texttt{done}}$.
The operation \texttt{step} non-deterministically adds a non-empty finite subset of unexplored elements and recomputes the minimum; \texttt{search\_min} returns the candidate once all elements have been processed.

\begin{figure}[htb]
	\centering
	\captionsetup{type=lstlisting}
	\begin{minipage}[b]{0.48\linewidth}
		\begin{lstlisting}[language=b, caption={Specification \texttt{MinSearch.mch}.}, label={lst:minsearch-mch}]
MACHINE MinSearch
CONSTANTS
  S
PROPERTIES
  S ∈ FIN1(INTEGER)
VARIABLES done, m
INVARIANT
  done ∈ FIN1(S) ∧
  m ∈ S          ∧
  m = min(done)
INITIALISATION
  ANY x WHERE x ∈ S
  THEN
    done := {x} || m := x
  END
\end{lstlisting}
	\end{minipage}\hfill
	\begin{minipage}[b]{0.48\linewidth}
		\begin{lstlisting}[language=b,firstnumber=last]
OPERATIONS
  mi <-- search_min =
    PRE done = S THEN
      mi := m
    END;
  step =
    IF done ≠ S THEN
      ANY add WHERE
        add ∈ FIN1(S - done)
      THEN
        done := done ∪ add ||
        m := min(done ∪ add)
      END
    END
END
\end{lstlisting}
	\end{minipage}
\end{figure}

This level already illustrates \barrel's treatment of partial operators: since $\bmin{\texttt{done}}$ and $\bmin{\texttt{done}\cup\texttt{add}}$ are only defined when the corresponding sets have a least element, \barrel generates the associated WD side obligations---either as theorems or subgoals depending on the context---alongside the usual proof obligations, and discharges them automatically using its built-in automation.
Remaining subgoals correspond to standard invariant preservation and operation correctness obligations.

\paragraph*{First refinement: reducing non-determinism}
The first refinement \texttt{MinSearch\_r1} tightens \texttt{step} to non-deterministically add a \emph{single} fresh element and update the minimum incrementally, as shown in Listing~\ref{lst:minsearch-r1-step}.

\begin{lstlisting}[language=b,caption={Refinement \texttt{MinSearch\_r1.ref} (excerpt): refined \texttt{step}.},label={lst:minsearch-r1-step}, float]
step =
  IF done ≠ S THEN
    ANY x WHERE x ∈ S - done THEN
      done := done ∪ {x} ||
      IF x < m THEN m := x END
    END
  END
\end{lstlisting}

Although the concrete update avoids recomputing \texttt{min}, refinement of the operation and invariant preservation still relate $\texttt{m}$ to $\bmin{\texttt{done}}$, so WD facts about \texttt{min} remain part of the proof landscape.
All 52 WD conditions are again automatically discharged by \barrel, while the remaining 9 POs correspond to standard refinement obligations.

\paragraph*{Second refinement: scanning an explicit table}
The second refinement \texttt{MinSearch\_r2} shown in Listing~\ref{lst:minsearch-r2} introduces an explicit enumeration and refines set exploration into a traversal using an index $\texttt{i}$ and a current minimum candidate $\texttt{mc}$.
A gluing invariant links the abstract set $\texttt{done}$ with $\texttt{tab[1..i]}$ (denoting the image of the interval \texttt{1..i} under \texttt{tab}) and identifies $\texttt{m}$ with $\texttt{mc}$, and states that $\texttt{mc}$ is a lower bound for all scanned entries.

\begin{figure}[htb]
	\centering
	\captionsetup{type=lstlisting}
	\begin{minipage}[b]{0.48\linewidth}%
		% \caption{Refinement \texttt{MinSearch\_r2.ref}.}
		% \label{lst:minsearch-r2}
		\begin{lstlisting}[language=b, caption={Refinement \texttt{MinSearch\_r2.ref}.}, label={lst:minsearch-r2}]
REFINEMENT MinSearch_r2
REFINES MinSearch_r1
CONSTANTS n, tab
PROPERTIES
  S ∈ FIN1(INTEGER) ∧
  tab ∈ 1..n ↣ S   ∧
  n = card(S)       ∧
  ran(tab) = S
VARIABLES i, mc
INVARIANT
  i ∈ 1..n          ∧
  m = mc            ∧
  done = tab[1..i]  ∧
  mc ∈ tab[1..i]    ∧
  ∀jj.(jj ∈ 1..i ⇒ mc ≤ tab(jj))
\end{lstlisting}
	\end{minipage}\hfill
	\begin{minipage}[b]{0.48\linewidth}
		\begin{lstlisting}[language=b,firstnumber=last]
INITIALISATION
  i := 1 || mc := tab(1)
OPERATIONS
  mi <-- search_min =
    PRE i = n THEN
      mi := mc
    END;
  step =
    IF i < n THEN
      i := i + 1;
      IF tab(i) < mc THEN
        mc := tab(i)
      END
    END
END
\end{lstlisting}
	\end{minipage}
\end{figure}

This level is particularly relevant for \barrel because it combines refinement obligations with multiple occurrences of different partial constructs like cardinality \texttt{card} and function application \texttt{tab(i)}.
Correctly discharging the resulting POs requires \barrel to generate and instantiate the corresponding WD conditions for every occurrence of such operators, which makes the number of WD subgoals grow significantly: 100 WD conditions are generated---and are all automatically discharged---alongside the 21 POs corresponding to standard refinement obligations.%\todo[Fix weird page break here]

\paragraph*{Discharging refinement POs inside Lean}

\begin{figure}[htb]
	\centering
	\begin{lstlisting}[language=lean,caption={Driving the refinement chain with \barrel.},label={lst:minsearch-lean}]
import machine    MinSearch    from "specs/case_study"
import refinement MinSearch_r1 from "specs/case_study"
import refinement MinSearch_r2 from "specs/case_study"

prove_obligations_of MinSearch
next ...  -- 4 remaining goals

prove_obligations_of MinSearch_r1
next ...  -- 9 remaining goals

prove_obligations_of MinSearch_r2
next ...  -- 21 remaining goals
\end{lstlisting}
\end{figure}

Working with \barrel involves standard Lean workflow: B files are imported and POs are generated as Lean theorems to be proved, as shown in Listing~\ref{lst:minsearch-lean}.

\begin{table}[htb]
	\centering
	\small
	\setlength{\tabcolsep}{4pt}
	% \renewcommand{\arraystretch}{1.05}
	\caption{Proof-obligation statistics for the \texttt{MinSearch} refinement chain.
		``\#PO'' excludes WD conditions, while ``\#WD'' counts them separately.
		``Auto'' counts obligations discharged without user interaction (Atelier~B: Force~1; Lean: \barrel default automation).
		Because Atelier~B and \barrel place WD obligations at different granularity (machine-level sharing vs.\ per-occurrence reification), ``\#WD'' counts are not expected to match one-to-one.}
	\label{tab:case-study-stats}
	\begin{tabular}{l|c|c|cc|cc}
		                       & \#PO (Atelier~B)                      & \#PO (\barrel)
		                       & \multicolumn{2}{c|}{\#WD (Atelier~B)} & \multicolumn{2}{c}{\#WD (\barrel)}                               \\
		\hline
		File                   & Total                                 & Total                              & Total & Auto & Total & Auto \\
		\hline
		\texttt{MinSearch}     & 4
		                       & 4
		                       & 4                                     & 4
		                       & 4                                     & 4                                                                \\
		\texttt{MinSearch\_r1} & 19
		                       & 9
		                       & 2                                     & 2
		                       & 52                                    & 52                                                               \\
		\texttt{MinSearch\_r2} & 21
		                       & 21
		                       & 9                                     & 9
		                       & 100                                   & 100                                                              \\
	\end{tabular}
\end{table}

In total for this case study, \barrel produces 190 goals across the three levels, 156 of which are WD conditions that are all automatically discharged using \barrel's underlying automation. The remaining 34 goals correspond to the expected proof obligations and are discharged with straightforward Lean proofs.
Table \ref{tab:case-study-stats} summarizes the size and proof obligation statistics of each artifact.
As expected, the number increases significantly with refinement, especially when moving to an explicit representation (\texttt{tab}) that introduces many occurrences of partial operators (notably application).
Fortunately, \barrel's automation should be \fixme[weird tense?] able to discharge most of the resulting WD conditions automatically, as showcased in this case study.

\subsection{Comparison with Atelier~B's interactive prover}\label{sec:lean-ip-comparison}
Atelier~B already provides effective automation and an interactive mode for discharging proof obligations; in particular, it is tightly integrated with the PO generator and can solve many goals using its built-in provers.
In practice, however, interactive proof in Atelier~B is primarily carried out through a dedicated, GUI-oriented workflow, where proof progress often depends on manual rule application and instantiation steps, especially for recurrent WD obligations.
Moreover, the interactive prover documentation explicitly warns that some instantiation commands, e.g.\@ \texttt{se} (\emph{suggest for exist}) for existentially quantified variables, do not enforce typing and well-definedness of user-provided terms, potentially leading to inconsistent proofs, as illustrated by the following example.

\begin{example}
	Consider the very simple B machine\footnote{This example is available as ``\texttt{DerivFalse.lean}'' in the artifacts.}, shown in Listing~\ref{lst:deriv-false}\fixme[I don't like that this is a floating listing with a caption \textit{inside} an example. I'd rather inline it so that it stays contained in the example and does not really need to be referenced. I agree that this will look out of place because all the other listings have captions, but I don't really have a better idea. Perhaps just remove the floating capabilities?], containing only one, clearly unprovable assertion.
	\begin{lstlisting}[language=b, caption={A simple B machine with a clearly unprovable assertion.}, label={lst:deriv-false}, float]
MACHINE DerivFalse
ASSERTIONS
  ∃ x. (x ∈ INTEGER ∧ x ∉ INTEGER)
END
\end{lstlisting}
	\fixme[``Yet,''?] Atelier~B's interactive prover allows discharging this assertion by executing the following commands in sequence in the interactive proof editor:
	\begin{itemize}
		\item \texttt{se(min($\varnothing$))}, instantiating the existential variable \texttt{x} with \texttt{min($\varnothing$)}, which is ill-defined since the empty set has no minimum: the prover does not check well-definedness here however;
		\item \texttt{mp} (\emph{mini-prover}) invoking internal automatic provers to close the goal.
	\end{itemize}
	Once falsehood is derived, any proof obligation can be discharged trivially by invoking command \texttt{ah} (\emph{add hypothesis}) with this contradiction as a hypothesis.
	This example is reproducible with all Community Edition releases of Atelier~B, up to the current latest 24.04.2.

\end{example}

% \footnote{
% 	The assertion $\exists x, x \in \mathbb{Z} \land x \notin \mathbb{Z}$---which is false in the B method---can be discharged in the interactive prover with the instantiation $x := \bmin{\varnothing}$ via the tactic \texttt{se} and a call to the automatic internal prover \texttt{pp}.}.

By contrast, \barrel lets users discharge the same obligations as ordinary Lean goals.
In particular, Lean tactics such as \texttt{exists} can only accept type-correct instantiations, hence ill-typed terms are rejected by construction; and under \barrel's encoding, partial B operators require explicit well-definedness proofs, so ill-defined instantiations---like \texttt{min($\varnothing$)}---cannot even be formed without providing the corresponding evidence.

Beyond these soundness guarantees, Lean provides a significantly richer proof-engineering ecosystem.
Once B obligations are expressed in Lean, users can leverage Mathlib's libraries and automation to simplify routine reasoning steps using normalization and algebraic tactics such as \texttt{ac\_rfl}, \texttt{ring} and related arithmetic tactics when needed.
This becomes particularly valuable when developments go beyond the integer/set-theoretic core of B, for instance by introducing real-valued models.