\section{Overview of \barrel}

\subsection{Background}
\noindent\info[Check where this belongs]
Set theory lies at the core of the B method.
That is, every value is a set that is constrained by some properties that define its shape.
For example, a (total) function $f$ from a set $A$ to a set $B$ (written $f \in A \longrightarrow B$) is a set of pairs in $A \times B$ satisfying the functionality property: for every $x \in A$ and $y,z \in B$, if $(x, y) \in f$ and $(x, z) \in f$ then $y = z$.
However, specifications written in the B method are still required to satisfy some typing predicates \todo[perhaps let's not talk about ``typing'' B?]: a ``parent set'' must be deducible for every constant and variable of a specification (except for intrinsics such as \texttt{INTEGER} or \texttt{POW}) \fixme[weird sentence].

\todo[TODO]

\begin{figure}[htb]
	\caption{High-level picture of \barrel.}

	\centering
	\begin{tikzpicture}[
			file/.style={chamfered rectangle, draw, chamfered rectangle corners=north west},
			entity/.style={rectangle, draw},
			node distance=1.5cm and 1.5cm,
			every node/.style={inner sep=6pt, align=center, minimum height=1.22cm, outer sep=0},
			% start chain = going right,
			arr/.style={->, shorten <=3pt, shorten >=3pt}
		]
		\node[file] (B mch) {.mch};
		\node[file, right=of B mch] (B bxml) {.bxml};
		\node[entity, right=of B bxml] (pos) {Proof\\obligations};
		\node[entity, right=of pos] (thms) {Lean\\theorems};

		\draw[arr] (B mch) -- node[above=-4mm, midway] {\scriptsize Parsing} (B bxml);
		\draw[arr] (B bxml) -- node[above=-6mm, midway] {\scriptsize PO\\[-.6ex]\scriptsize generation} (pos);
		\draw[arr] (pos) -- node[above=-6mm, midway] {\scriptsize PO\\[-.6ex]\scriptsize encoding} (thms);
		\draw[arr, shorten <=7pt, shorten >=7pt] (thms.south) arc[start angle=220, end angle=500, x radius=9.5mm, y radius=9.5mm] node[midway, fill=white, minimum height=0pt, inner sep=2pt] {\scriptsize Proving};
	\end{tikzpicture}
\end{figure}

\paragraph*{Foundations of B in Lean}
%
We leverage these typing annotations and ground our encoding in typed higher order logic (rather than ZFC set theory) by using Mathlib's \texttt{Set} and \texttt{SetRel} types\footnote{Which are defined respectively as $\mathtt{Set}\ \alpha \triangleq \alpha \to \mathtt{Prop}$ and $\mathtt{SetRel}\ \alpha\ \beta \triangleq \mathtt{Set}(\alpha \times \beta)$.} to represent sets and relations.
This is a convenient representation since Mathlib comes
% batteries included\fixme[remove?] 
with many definitions and theorems related to \texttt{Set} for us to use when proving the translated obligations in Lean.
This representation also allows us to express every kind of set used in B specifications since all sets in B are required to be \emph{homogeneous}, i.e.\@ restricted to a uniform shape of elements.
For instance, the set $\{0, "hi"\}$ must be considered ill-formed by implementations of the B method.
% this also enables us to easily reason about sets using the plethora of theorems and definitions that Mathlib puts at our disposal.

\info[moved from the intro]
A central challenge in this setting is the use of partial B operators.
Function application, the minimum and maximum of a set, and cardinality are all only defined under suitable well-formedness (WF) conditions.
Atelier~B typically handles these via additional WF proof obligations, which are generated \emph{after} the main obligations, expecting that they will be later instantiated when needed.
Lean, on the other hand, has no built-in notion of partiality and must therefore exhibit WF conditions as explicit proof parameters of the relevant functions.
This also means that one cannot construct a term depending on a partial operator without providing a proof that it is well-formed.
From the user's perspective, the discharger presents a sequence of goals where WF obligations appear explicitly, ahead of the original PO, and all of them can be proved using the usual tactic language and existing library lemmas.

We start by defining standard B operators directly in Lean---reusing their notations from B, in order for the POs to be easily understandable by B users---and typing them appropriately in Lean to keep their use as generic as possible.
Some examples (the set of relations, the set of total injective functions and domain subtraction) are given in \cref{lst:B-sets-lean}.
%
\begin{lstlisting}[label=lst:B-sets-lean, caption={Encoding of some B operators in Lean.}]
abbrev rels {Î± Î²} (A : Set Î±) (B : Set Î²) : Set (SetRel Î± Î²) :=
  ð’« (A Ã—Ë¢ B)
scoped infixl:125 "  âŸ·  " => rels

abbrev injTFun {Î± Î²} (A : Set Î±) (B : Set Î²) : Set (SetRel Î± Î²) :=
  A â¤” B âˆ© A  âŸ¶  B
scoped infixl:125 " â†£ " => injTFun

abbrev domSubtr {Î± Î²} (E : Set Î±) (R : SetRel Î± Î²) : SetRel Î± Î² :=
  { z âˆˆ R | z.1 âˆ‰ E }
scoped infixl:160 " â©¤ " => domSubtr
\end{lstlisting}
%
We then provide proofs, using Mathlib's infrastructure and theorems, of various laws and theorems of B: for any total function $f \in A \longrightarrow B$ its domain $\bdom{f}$ equals $A$; assuming that $a \le b$, the minimum of $\binterval{a}{b}$ is $a$; etc.
Both the definitions and theorems are readily available to end users when importing \barrel in a Lean project, and serve as basic building blocks for proofs of B obligations translated by our tool.

% abbrev pfun {Î± Î²} (A : Set Î±) (B : Set Î²) : Set (SetRel Î± Î²) :=
%   { f âˆˆ A  âŸ·  B | âˆ€ â¦ƒx y zâ¦„, (x, y) âˆˆ f â†’ (x, z) âˆˆ f â†’ y = z }
% scoped infixl:125 " â‡¸ " => pfun

\paragraph*{Encoding partial B operators}

Some operators of the B language are said to be partial, meaning that they are only defined when some well-formedness (WF) conditions are satisfied.
A typical example of such an operator is the minimum operator $\bmin{S}$, which when given a set $S$ returns its smallest element (w.r.t.\@ the ordering $\le$ on integers or reals), if it exists, and is undefined otherwise.
These partial operators are typically encoded using Hilbert's bounded choice operator $\epsilon\ x \in S.\ P$ which is undefined if no element of $S$ satisfy $P$.
The \emph{WF condition} of the corresponding operator is that $P$ is satisfied by (at least) an element of $S$.

Atelier B handles this partiality by generating the WF conditions of each partial operator as side goals and assumes in the main goal that the partial operators are well-defined.
However, one must trust that these WF conditions actually correspond to the WF conditions that are expected from the context of those partial operators, and there is no clear dependency---even after inspecting the generated POG file---between the main goal and the WF side goals.

Our approach in \barrel differs from Atelier B in that the dependency between the WF goals and the main goals is clear and explicit.
%
First, we do not rely on the WF conditions that are generated by Atelier B and instead generate our own to match the exact context in which they are inserted.
This is not necessarily true of the WF conditions generated by Atelier B since they undergo some simplification steps or do not match exactly our encoding of some predicates.
In practice, our tool generates WF side goals that are equivalent to the WF side goals generated by Atelier B.
%
Then, we take advantage of the dependent types of Lean to encode partial operators using \texttt{Classical.choose} (Hilbert's $\epsilon$ operator, but in Lean) which explicitly depends on a proof that the predicate is satisfied by at least one element\footnote{By doing so we encode partial operators as total functions: since they now explicitly depend on the proof of the WF condition, they cannot be undefined anymore.}.
The statement of this proof, which is the WF condition of the operator, is then generated as a side theorem which must be discharged for the main theorem to be fully proven, i.e.\@ not depend on the \texttt{sorryAx} axiom (the axiom that is introduced by admitted theorems).
To illustrate this use of \texttt{Classical.choose}, the encoding (and WF conditions) of $\bmin{S}$ and function application $\bapp{F}{x}$ are given in \cref{lst:min-fn-app}.

\begin{lstlisting}[label=lst:min-fn-app, caption={Encoding of the $\bmin{S}$ and $\bapp{F}{x}$ partial operators.}]
structure min.WF {Î±} [LinearOrder Î±] (S : Set Î±) : Prop where
  isBoundedBelow : âˆƒ x âˆˆ S, âˆ€ y âˆˆ S, x â‰¤ y

noncomputable 
abbrev min {Î±} [LinearOrder Î±] (S : Set Î±) (wf : min.WF S) : Î± :=
  Classical.choose wf.isBoundedBelow

structure app.WF {Î± Î²} (f : SetRel Î± Î²) (x : Î±) : Prop where
  isPartialFunction : f âˆˆ dom f  âŸ¶  ran f
  isInDomain : x âˆˆ dom f

noncomputable 
abbrev app {Î± Î²} (f : SetRel Î± Î²) (x : Î±) (wf : app.WF f x) : Î² :=
  Classical.choose wf.isInDomain
scoped notation:290 F:290 "(" x:min ")'" wf:300 => app F x wf
\end{lstlisting}