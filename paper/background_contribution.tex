\section{Overview of \barrel}

This section presents \barrel and its workflow as depicted by \cref{fig:barrel-archi}.
We first recall the B method, then explain how \barrel handles well-definedness conditions and finally detail its inner workings and automation features.

\subsection{Background}

\paragraph*{The B method and proof obligations}
The B method is a state-based formal development approach centered on \emph{machines} and stepwise \emph{refinement}.
A machine declares abstract sets and constants, a state described by variables constrained by an invariant, an initialization, and operations.
A development proceeds by refining an abstract machine into more concrete refinements down to an implementation, introducing representation data together with a \emph{gluing invariant} relating concrete and abstract states.
From each machine and refinement step, Atelier~B generates \emph{proof obligations} (POs): logical sequents whose discharge guarantees that the model is consistent and that refinement is correct.
Concretely, POs cover invariant preservation by the initialization and each operation under its precondition, and simulation-style obligations ensuring that concrete operations preserve the abstract behavior through the gluing invariant.
In addition, the PO generator emits \emph{well-definedness} (WD) obligations for the many partial constructs of the language.

POs can be discharged automatically using Atelier~B‚Äôs internal provers and by delegating to external backends.
In particular, several approaches translate B obligations to SMT solvers such as Z3~\cite{z3} or cvc5~\cite{cvc5} via dedicated encodings, including the \emph{ppTransSMT}~\cite{DeharbeBSMT} and the more recent \emph{BEer}~\cite{beer} encodings.
Obligations that remain---often those requiring non-trivial quantifier instantiation, refinement reasoning, or tedious WD bookkeeping---are typically discharged interactively using Atelier~B‚Äôs GUI-oriented prover, where the user guides rule applications and instantiations.

\paragraph*{The B language in a nutshell}
% Set theory lies at the core of the B method.
B's mathematical language is based on classical set theory and first-order logic with equality.
Specifications are written using the usual set-theoretic constructors such as comprehension, powerset, cartesian product, and an algebra of relations.
Ordered pairs are first-class values (written as \emph{maplets} $x \mapsto y$), and relations are simply sets of such pairs, i.e.\@ $R \subseteq A \times B$.
Functions are not primitive: a partial function $f$ from $A$ to $B$ (written $f \in A \pfun B$) is a relation $f \subseteq A \times B$ whose domain is contained in $A$ and which is \emph{functional}:
for all $x \in A$ and $y,z \in B$, if $(x \mapsto y) \in f$ and $(x \mapsto z) \in f$ then $y = z$.
Total ($A \longrightarrow B$), injective (partial $A \pinj B$ and total $A \tinj B$), and surjective (partial $A \psurj B$ and total $A \tsurj B$) variants are defined similarly as usual.

% That is, every value is a set that is constrained by some properties that define its shape.
% For example, a (total) function $f$ from a set $A$ to a set $B$ (written $f \in A \longrightarrow B$) is a set of pairs in $A \times B$ satisfying the functionality property: for every $x \in A$ and $y,z \in B$, if $(x, y) \in f$ and $(x, z) \in f$ then $y = z$.
% However, specifications written in the B method are still required to satisfy some typing predicates \todo[perhaps let's not talk about ``typing'' B?]: a ``parent set'' must be deducible for every constant and variable of a specification.
Although the underlying logic is set-theoretic and thus untyped, Atelier~B enforces a static well-formedness discipline often described as ‚Äútyping‚Äù: every identifier and expression must be assigned a ``parent set'' that must be deducible for every constant, variable, and expression in a specification.
This guarantees in particular that constructed sets are homogeneous and rules out ill-formed terms.
These inferred parent sets provide exactly the information needed to interpret B expressions in Lean's typed logic in our translation.

\begin{example}
  The expression $1 + \top$ is well-formed in ZFC set theory---and definitionally equal to the set $\mathbb{B}$ of Booleans, or the natural number $2$---but it is not a valid expression in B.
	Indeed, $1$ has parent set $\mathbb{Z}$ and $\top$ has parent set $\mathbb{B}$, and $+$ expects both its arguments to have parent set $\mathbb{Z}$.
\end{example}

\paragraph*{Foundations of B in Lean}
%
We leverage these typing annotations and ground our encoding in typed higher order logic (rather than ZFC set theory) by using Mathlib's \texttt{Set} and \texttt{SetRel} types\footnote{Which are defined respectively as $\mathtt{Set}\ \alpha \triangleq \alpha \to \mathtt{Prop}$ and $\mathtt{SetRel}\ \alpha\ \beta \triangleq \mathtt{Set}(\alpha \times \beta)$.} to represent sets and relations:
each inferred B carrier is mapped to a corresponding Lean type---\texttt{INTEGER} to \texttt{Int}, cartesian products to Lean product types, and powersets to \texttt{Set} over the element type.
This is a convenient representation since Mathlib comes
% batteries included\fixme[remove?] 
with many definitions and theorems related to \texttt{Set} for us to use when proving the translated obligations in Lean.
This representation also allows us to express every kind of set used in B specifications since all sets in B are required to be \emph{homogeneous}, i.e.\@ restricted to a uniform shape of elements.
For instance, the set $\{0, "hi"\}$ must be considered ill-formed by implementations of the B method.
% this also enables us to easily reason about sets using the plethora of theorems and definitions that Mathlib puts at our disposal.

We start by defining standard B operators directly in Lean---reusing their notations from B, in order for the POs to be easily understandable by B users---and typing them appropriately in Lean to keep their use as generic as possible.
Some examples (the set of relations, the set of partial functions, the set of total injective functions and domain subtraction) are given in \cref{lst:B-sets-lean}.
%
\begin{lstlisting}[label=lst:B-sets-lean, caption={Encoding of some B operators in Lean.}, float=t]
abbrev rels {Œ± Œ≤} (A : Set Œ±) (B : Set Œ≤) : Set (SetRel Œ± Œ≤) :=
  ùí´ (A √óÀ¢ B)
scoped infixl:125 "  ‚ü∑  " => rels

abbrev pfun {Œ± Œ≤} (A : Set Œ±) (B : Set Œ≤) : Set (SetRel Œ± Œ≤) :=
  { f ‚àà A  ‚ü∑  B | ‚àÄ ‚¶Éx y z‚¶Ñ, (x, y) ‚àà f ‚Üí (x, z) ‚àà f ‚Üí y = z }
scoped infixl:125 " ‚á∏ " => pfun

abbrev injTFun {Œ± Œ≤} (A : Set Œ±) (B : Set Œ≤) : Set (SetRel Œ± Œ≤) :=
  A ‚§î B ‚à© A  ‚ü∂  B
scoped infixl:125 " ‚Ü£ " => injTFun

abbrev domSubtr {Œ± Œ≤} (E : Set Œ±) (R : SetRel Œ± Œ≤) : SetRel Œ± Œ≤ :=
  { z ‚àà R | z.1 ‚àâ E }
scoped infixl:160 " ‚©§ " => domSubtr
\end{lstlisting}
%
We then provide proofs, using Mathlib's infrastructure and theorems, of various laws and theorems of B: for any total function $f \in A \longrightarrow B$ its domain $\bdom{f}$ equals $A$; assuming that $a \le b$, the minimum of $\binterval{a}{b}$ is $a$; etc.
Both the definitions and theorems are readily available to end users when importing \barrel in a Lean project, and serve as basic building blocks for proofs of B obligations translated by our tool.

\subsection{Encoding partial B operators}
A central challenge in this setting is the use of \emph{partial} B operators, meaning that they are only defined when some \emph{well-definedness} (WD) conditions are satisfied.
A typical example of such an operator is the minimum operator $\bmin{S}$, which when given a set $S$ (of integers or reals) returns its smallest element (w.r.t.\@ the ordering $\le$ on integers or reals), if it exists, and is undefined otherwise.
These partial operators are typically encoded using Hilbert's bounded choice operator $\epsilon\ x \in S.\ P$, which is left unspecified if no element of $S$ satisfies $P$.
The \emph{WD condition} of the corresponding operator is precisely that $P$ is satisfied by (at least) an element of $S$.

Atelier B handles this partiality by generating the WD conditions of each partial operator used in a PO as side goals and assumes in the main goal that the partial operators are well-defined.
However, one must trust that these WD conditions actually correspond to the WD conditions that are expected from the context of those partial operators, and there is no clear dependency---even after inspecting the generated POG file---between the main goal and the WD side goals.
Furthermore, these WD conditions are only generated for the goal itself but not during proof steps.
This can lead to inconsistencies if the user is not careful enough for instance when instantiating quantified variables in the interactive prover\footnote{This is concretely illustrated below in \cref{sec:lean-ip-comparison}.}.

Our approach in \barrel differs from Atelier B in that the dependency between the WD goals and the main goals is clear and explicit.\todo[Ask Stephan]
%
First, we do not rely on the WD conditions that are generated by Atelier B and instead generate our own to match the exact context in which they are inserted.
This is not necessarily true of the WD conditions generated by Atelier B since they undergo some simplification steps or do not match exactly our encoding of some predicates and WD conditions.

\begin{remark}
Atelier B's WD conditions for the $\bminop{}$ and $\bmaxop{}$ operators are slightly different from ours.
For instance, it treats integers and reals differently: a set $S$ of integers admits a minimum if it is non-empty when intersected with $\mathbb{N}$, and a maximum if it is non-empty when intersected with $-\mathbb{N}$; whereas for reals, $S$ must be non-empty and bounded below (resp.\@ above) to admit a minimum (resp.\@ maximum).
\barrel makes use of the same WD conditions for both integers, reals, and actually any type implementing a \emph{partial order}, requiring non-emptiness and boundedness below (resp.\@ above) for minimum (resp.\@ maximum)---which is logically equivalent in the case of integers, yet more generic:
\begin{lstlisting}[language=lean]
theorem min.WD_iff_AtelierB_WD {S : Set ‚Ñ§} :
	min.WD S ‚Üî S ‚â† ‚àÖ ‚àß S ‚à© (INTEGER \ NATURAL) ‚àà FIN INTEGER
theorem max.WD_iff_AtelierB_WD {S : Set ‚Ñ§} :
	max.WD S ‚Üî S ‚â† ‚àÖ ‚àß S ‚à© NATURAL ‚àà FIN INTEGER
\end{lstlisting}
\end{remark}

In practice, our tool generates WD side goals that are equivalent to the WD side goals generated by Atelier B.
The only difference is that Atelier~B may remove unnecessary hypotheses and perform basic simplification on the WD goals at generation time, which may alter the PO, whereas our WD conditions are generated from the exact Lean context.
% \footnote{\todo[Should this footnote be kept?] To be accurate, our WD conditions are generated from the exact Lean context whereas Atelier~B already performs simplification steps at this point, which may alter the PO.}
%
Then, we take advantage of the dependent types of Lean to encode partial operators using \texttt{Classical.choose} (Hilbert's $\epsilon$ operator, in Lean, whose type is \mbox{$\{\alpha : \mathtt{Sort}\ u\} \to \{p : \alpha \to \mathtt{Prop}\} \to (\exists\, x,\, p\ x) \to \alpha$}) which explicitly depends on a proof that the predicate is satisfied by at least one element.\footnote{Lean has no built-in notion of partiality and must therefore exhibit WD conditions as explicit proof parameters of the relevant total functions.}
This means that one cannot construct a term depending on a partial operator without providing a proof that it is well-defined.
The statement of this proof, which is the WD condition of the operator, is then generated as a side theorem (or a subgoal) which must be discharged for the main theorem to be fully proven, i.e.\@ not depend on the \texttt{sorryAx} axiom---the axiom that is introduced by admitted theorems.
To illustrate this use of \texttt{Classical.choose}, the encoding (and WD conditions) of $\bmin{S}$ and function application $\bapp{F}{x}$ are given in \cref{lst:min-fn-app}.

\begin{lstlisting}[language=lean, mathescape=true, label=lst:min-fn-app, caption={Encoding of the $\bmin{S}$ and $\bapp{F}{x}$ partial operators.}, float=t]
structure min.WD {Œ±} [LinearOrder Œ±] (S : Set Œ±) : Prop where
  isBoundedBelow : ‚àÉ x ‚àà S, ‚àÄ y ‚àà S, x ‚â§ y

noncomputable 
abbrev min {Œ±} [LinearOrder Œ±] (S : Set Œ±) (wd : min.WD S) : Œ± :=
  Classical.choose wd.isBoundedBelow

structure app.WD {Œ± Œ≤} (f : SetRel Œ± Œ≤) (x : Œ±) : Prop where
  isPartialFunction : f ‚àà dom f  ‚ü∂  ran f
  isInDomain : x ‚àà dom f -- $\textcolor{commentcolor}{\equiv\ \exists}$ y, (x, y) $$‚àà f

noncomputable 
abbrev app {Œ± Œ≤} (f : SetRel Œ± Œ≤) (x : Œ±) (wd : app.WD f x) : Œ≤ :=
  Classical.choose wd.isInDomain
\end{lstlisting}

\subsection{Inner Workings of \barrel and Automation}
\label{sec:innner-workings}

\paragraph*{User-level workflow}

\barrel is organized into four distinct passes.
First, the machine/system/refinement/implementation is parsed into the BXML format, and proof obligations are generated from this format using Atelier B's internal tools \texttt{bxml} and \texttt{pog}.

Although Atelier~B's \texttt{pog} can generate WD conditions for the given machine, we choose to rely on our own generation instead, since the WD conditions that are generated by \texttt{pog} may not exactly match the context in which they will appear in the Lean terms.
Then, the resulting POs (in XML format) are parsed by \barrel into an Abstract Syntax Tree (AST) and normalized.
Normalization\todo[Ask Stephan] ensures that B predicates like $P \land Q \Rightarrow R$ are treated the same as the logically equivalent predicate $P \Rightarrow Q \Rightarrow R$.
Although it is unnecessary, we perform normalization of B terms solely for the purpose of generating Lean goals that overall require fewer conjunction destructions.
The normalized B formulas are then transcribed into Lean terms using Lean's facilities for meta-programming and elaboration.
However, a lot of bookkeeping has to happen in order to encode partial B operators, since they rely on WD conditions that must be inserted on the fly.
Instead of handling the bookkeeping ourselves, we let Lean handle it internally by generating meta-variables (containing their local contexts) in place of the WD conditions.
We later assign the generated meta-variables with fresh theorem names whose propositions are extracted from the context of the meta-variable.
%
\begin{example}
	%
	Let us illustrate how WD conditions are handled by \barrel on the following (already normalized) B predicate, stating that every non-empty finite set of integers---i.e.\@ belonging to $\bfinone{\mathbb{Z}}$---whose elements are non-positive has a minimal element that is non-positive: \[
		\forall S \cdot (S \in \bfinone{\mathbb{Z}} \Rightarrow (\forall x \cdot x \in S \Rightarrow x \le 0) \Rightarrow \bmin{S} \le 0)
	\]
	%
	The first step of the pipeline is generating a Lean term while inserting meta-variables in place of WD conditions (where $h_1$, $h_2$ and $h_3$ are fresh identifiers):
	\[
		\begin{split}
			P := \forall\, & (S : \mathtt{Set}\, \mathbb{Z})\, (h_1 : S \in \mathtt{B.Builtins.FIN_1}\ \mathbb{Z})                                                 \\
			               & \quad (h_2 : \forall\, (x : \mathbb{Z})\, (h_3 : x \in S),\ x \le 0),\ \mathtt{B.Builtins.min}\ S\ (\metavar{m_1}\ S\ h_1\ h_2) \le 0
		\end{split}
	\]
	The new meta-variable $\metavar{m_1}$ is generated internally by \barrel, and contains $S : \mathtt{Set}\ \mathbb{Z}$, $h_1 : S \in \mathtt{B.Builtins.FIN_1}\ \mathbb{Z}$ and $h_2 : \forall\, (x : \mathbb{Z})\ (h_3 : x \in S),\ x \le 0$ in its local context.
	Although its type is $\mathtt{B.Builtins.min.WD}\ S$, its local context is implicitly universally quantified, hence the full application $\metavar{m_1}\ S\ h_1\ h_2$ in the goal.
	%
	A fresh theorem statement $min\_wd_1$ is then generated---and remains to be proved---from the type of $\metavar{m_1}$ universally quantified by its local context: \[
		\begin{split}
			\mathtt{theorem}\ min\_wd_1 : \forall\, & (S : \mathtt{Set}\ \mathbb{Z})\, (h_1 : S \in \mathtt{B.Builtins.FIN_1}\ \mathbb{Z})                 \\
			                                 & \quad (h_2 : \forall\, (x : \mathbb{Z})\, (h_3 : x \in S),\ x \le 0),\ \mathtt{B.Builtins.min.WD}\ S
		\end{split}
	\]
	$\metavar{m_1}$ is finally assigned $min\_wd_1$, and substituted in $P$ to obtain the final goal to be proved by the user: \[
		\begin{split}
			\vdash \forall\, & (S : \mathtt{Set}\ \mathbb{Z})\, (h_1 : S \in \mathtt{B.Builtins.FIN_1}\ \mathbb{Z}) (h_2 : \forall\, (x : \mathbb{Z})\, (h_3 : x \in S),\ x \le 0),\                                      \\
			                 & \quad \mathtt{B.Builtins.min}\ S\ (min\_wd_1\ S\ h_1\ h_2) \le 0
		\end{split}
	\]
\end{example}

All these previous steps are performed by the \texttt{import <type> <name> from <folder>} command of our tool.
\texttt{<type>} may be one of \texttt{machine}, \texttt{system}, \texttt{refinement}, \texttt{implementation} or \texttt{pog} depending on whether the file to be imported is a machine, system, refinement, implementation or straight up a POG file, and \texttt{<name>} is the file name without the extension.
In the case of POG files, the first step converting into the BXML format is skipped.
Finally, the command \texttt{prove\_obligations\_of <name>} gives back all the generated WD conditions and propositions to the user for them to prove.
Each WD condition and proposition is then inserted into the global context as a theorem, which the user can re-use instead of duplicating proofs or check for no use of the \texttt{sorryAx} axiom---so that every obligation is fully proven.


% : \begin{itemize}
% 	\item 
% 	\item 
% 	\item Then, the formulas are transcribed into Lean terms using Lean's facilities for meta-programming/elaboration.
% 	\item Finally, these Lean terms and their associated WD conditions are presented to the user who fills out the proofs.
% \end{itemize}

% The first three steps are performed by the command \texttt{import machine <name> from <folder>}.

% \noindent\todo[Inner workings]

\paragraph*{Proof automation}
\label{par:automation}
Before presenting goals to the user, \barrel runs a lightweight, predictable automation pass whose primary purpose is to discharge routine side conditions induced by our encoding of B partial operators.
Concretely, the tactic layer repeatedly applies potentially relevant lemmas---backtracking as needed---that relate WD subgoals and available hypotheses.
These helper lemmas provide definitional equations and rewriting/simplification facts for the B constructs supported by \barrel about sets, relations, functions, arithmetic and finiteness idioms, so that many generated WD goals reduce to elementary facts about membership, domain/range inclusion, finiteness, and order bounds and can be closed automatically.
We leverage Mathlib's features to tag helper lemmas with relevant categories---\texttt{wd\_min}, \texttt{wd\_max}, \texttt{wd\_app}, \texttt{wd\_card}---and tap into its rich library of set-theoretic results to keep the tactic small and focused.
To those tags also correspond the names of the tactics that are run automatically by \barrel's automation layer, so that users may also invoke them manually when needed or extend them with their own lemmas.


Beyond the core encoding of B primitives, \barrel comes with a curated---still small, but already well-furnished---library of theorems about built-in operators.
Its purpose is twofold:
\begin{enumerate}
	\item provide reusable WD facts that discharge the side goals generated for partial operators;
	\item offer canonical rewrite lemmas that turn B-shaped expressions into ``Mathlib-friendly'' goals.
\end{enumerate}
For instance, in the arithmetic fragment used throughout our running examples, the library includes dedicated WD lemmas for the minimum operation, as shown in \cref{lst:min-wd-lemmas}, each of them being tagged with the relevant theorem category.

\begin{lstlisting}[language=lean, caption={Some WD lemmas about extrema in our B library.}, label=lst:min-wd-lemmas, float]
@[wd_min]
theorem min.WD_singleton {Œ± : Type _} [PartialOrder Œ±] {a : Œ±} :
	min.WD {a} := ‚ãØ
@[wd_min]
theorem min.WD_of_finite {Œ± : Type _} [LinearOrder Œ±] {S A : Set Œ±}
	(h : S ‚àà FIN‚ÇÅ A) : min.WD S := ‚ãØ
@[wd_min]
theorem min.WD_interval {lo hi : ‚Ñ§} (h : lo ‚â§ hi) :
	min.WD (lo..hi) := ‚ãØ
\end{lstlisting}

The library also provides basic membership results about finite sets and intervals; and in the same spirit, ``computational'' equalities are exposed as rewrite rules, again all tagged appropriately to be picked up by relevant automation, as shown in \cref{lst:finset-interval-lemmas}---with proofs replaced by $\leanpf$ for brevity.

\begin{lstlisting}[language=lean, caption={Some membership lemmas about finite sets and intervals in our B library.}, label=lst:finset-interval-lemmas, float]
theorem interval.FIN‚ÇÅ_mem {lo hi : ‚Ñ§} (h : lo ‚â§ hi) :
	lo .. hi ‚àà FIN‚ÇÅ INTEGER := ‚ãØ
@[simp]
theorem min.of_singleton {Œ± : Type _} [PartialOrder Œ±] {a : Œ±} :
	min {a} (min.WD_singleton) = a := ‚ãØ
@[simp]
theorem interval.min_eq {lo hi : Int} (h : lo ‚â§ hi) :
	min (lo .. hi) (min.WD_interval h) = lo := ‚ãØ
\end{lstlisting}
\todo[Do we really want to explain how Lean handles attributes??]

The remaining obligations---typically invariant preservation and refinement simulation goals---are left as interactive proof tasks, keeping the automation transparent and predictable while still removing most of the WD bookkeeping arising from B developments.
\todo[Ask Stephan about: ``It would be interesting if you could comment on your experience with the implementation of this layer within Lean: was the provided infrastructure helpful, what's the size of the library that you implemented?'']

\paragraph*{Trust boundary and guarantees}
\barrel should be understood as a \emph{proof-producing backend} for the obligations it emits:
once a proof script succeeds, the corresponding theorem is checked by Lean's kernel.
Concretely, the remaining trusted assumptions are:
\begin{itemize}
	\item Lean's kernel, and its standard meta-theory,
	\item the correctness of the external PO generation step performed by Atelier~B (\texttt{bxml}/\texttt{pog}) at \barrel's import phase,
	\item the faithfulness of \barrel's set-theoretic embedding of B constructs and proof obligations to the intended B semantics.
\end{itemize}
What \barrel \emph{does} guarantee by construction is that partial B operators cannot be used in generated Lean terms without supplying explicit WD evidence, and that any successfully discharged goal yields a kernel-checked Lean theorem---i.e.\@ a Lean (proof-)term having the right type---under that embedding.
A fully independent chain would additionally require a verified PO generator, which we leave as future work.