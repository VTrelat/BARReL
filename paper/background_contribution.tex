\section{Overview of \barrel}

\subsection{Background}

\paragraph*{The B method and proof obligations}
The B method is a state-based formal development approach centered on \emph{machines} and stepwise \emph{refinement}.
A machine declares abstract sets and constants, a state described by variables constrained by an invariant, an initialization, and operations.
A development proceeds by refining an abstract machine into more concrete refinements down to an implementation, introducing representation data together with a \emph{gluing invariant} relating concrete and abstract states.
From each machine and refinement step, Atelier~B generates proof obligations (POs): logical sequents whose discharge guarantees that the model is consistent and that refinement is correct.
Concretely, POs cover invariant preservation by the initialization and each operation under its precondition, and simulation-style obligations ensuring that concrete operations preserve the abstract behavior through the gluing invariant.
In addition, the PO generator emits well-definedness (WD) obligations for the many partial constructs of the language.

POs can be discharged automatically using Atelier~Bâ€™s internal provers and by delegating to external backends.
In particular, several approaches translate B obligations to SMT solvers such as Z3~\cite{z3} or cvc5~\cite{cvc5} via dedicated encodings, including the historical \emph{ppTransSMT}~\cite{DeharbeBSMT} and the more recent \emph{BEer}~\cite{beer} encodings.
Obligations that remain---often those requiring non-trivial quantifier instantiation, refinement reasoning, or tedious WD bookkeeping---are typically discharged interactively using Atelier~Bâ€™s GUI-oriented prover, where the user guides rule applications and instantiations.

\paragraph*{The B language in a nutshell}
% Set theory lies at the core of the B method.
B's mathematical language is based on classical set theory and first-order logic with equality.
Specifications are written using the usual set-theoretic constructors such as comprehension, powerset, cartesian product, and an algebra of relations.
Ordered pairs are first-class values (written as \emph{maplets} $x \mapsto y$), and relations are simply sets of such pairs, \emph{i.e.}\@ $R \subseteq A \times B$.
Functions are not primitive: a (partial) function $f$ from $A$ to $B$ (written $f \in A \pfun B$) is a relation $f \subseteq A \times B$ whose domain is contained in $A$ and which is \emph{functional}:
for all $x \in A$ and $y,z \in B$, if $(x \mapsto y) \in f$ and $(x \mapsto z) \in f$ then $y = z$.
Total, injective, and surjective variants are defined similarly as usual.

% That is, every value is a set that is constrained by some properties that define its shape.
% For example, a (total) function $f$ from a set $A$ to a set $B$ (written $f \in A \longrightarrow B$) is a set of pairs in $A \times B$ satisfying the functionality property: for every $x \in A$ and $y,z \in B$, if $(x, y) \in f$ and $(x, z) \in f$ then $y = z$.
% However, specifications written in the B method are still required to satisfy some typing predicates \todo[perhaps let's not talk about ``typing'' B?]: a ``parent set'' must be deducible for every constant and variable of a specification.
Although the underlying logic is set-theoretic and thus untyped, Atelier~B enforces a static well-formedness discipline often described as â€œtypingâ€: every identifier and expression must be assigned a ``parent set'' that must be deducible for every constant, variable, and expression in a specification.
This guarantees in particular that constructed sets are homogeneous and rules out ill-formed terms.
These inferred parent sets provide exactly the information needed to interpret B expressions in Lean's typed logic in our translation.

\paragraph*{Foundations of B in Lean}
%
We leverage these typing annotations and ground our encoding in typed higher order logic (rather than ZFC set theory) by using Mathlib's \texttt{Set} and \texttt{SetRel} types\footnote{Which are defined respectively as $\mathtt{Set}\ \alpha \triangleq \alpha \to \mathtt{Prop}$ and $\mathtt{SetRel}\ \alpha\ \beta \triangleq \mathtt{Set}(\alpha \times \beta)$.} to represent sets and relations.
This is a convenient representation since Mathlib comes
% batteries included\fixme[remove?] 
with many definitions and theorems related to \texttt{Set} for us to use when proving the translated obligations in Lean.
This representation also allows us to express every kind of set used in B specifications since all sets in B are required to be \emph{homogeneous}, i.e.\@ restricted to a uniform shape of elements.
For instance, the set $\{0, "hi"\}$ must be considered ill-formed by implementations of the B method.
% this also enables us to easily reason about sets using the plethora of theorems and definitions that Mathlib puts at our disposal.

We start by defining standard B operators directly in Lean---reusing their notations from B, in order for the POs to be easily understandable by B users---and typing them appropriately in Lean to keep their use as generic as possible.
Some examples (the set of relations, the set of partial functions, the set of total injective functions and domain subtraction) are given in \cref{lst:B-sets-lean}.
%
\begin{lstlisting}[label=lst:B-sets-lean, caption={Encoding of some B operators in Lean.}, float]
abbrev rels {Î± Î²} (A : Set Î±) (B : Set Î²) : Set (SetRel Î± Î²) :=
  ð’« (A Ã—Ë¢ B)
scoped infixl:125 "  âŸ·  " => rels

abbrev pfun {Î± Î²} (A : Set Î±) (B : Set Î²) : Set (SetRel Î± Î²) :=
  { f âˆˆ A  âŸ·  B | âˆ€ â¦ƒx y zâ¦„, (x, y) âˆˆ f â†’ (x, z) âˆˆ f â†’ y = z }
scoped infixl:125 " â‡¸ " => pfun

abbrev injTFun {Î± Î²} (A : Set Î±) (B : Set Î²) : Set (SetRel Î± Î²) :=
  A â¤” B âˆ© A  âŸ¶  B
scoped infixl:125 " â†£ " => injTFun

abbrev domSubtr {Î± Î²} (E : Set Î±) (R : SetRel Î± Î²) : SetRel Î± Î² :=
  { z âˆˆ R | z.1 âˆ‰ E }
scoped infixl:160 " â©¤ " => domSubtr
\end{lstlisting}
%
We then provide proofs, using Mathlib's infrastructure and theorems, of various laws and theorems of B: for any total function $f \in A \longrightarrow B$ its domain $\bdom{f}$ equals $A$; assuming that $a \le b$, the minimum of $\binterval{a}{b}$ is $a$; etc.
Both the definitions and theorems are readily available to end users when importing \barrel in a Lean project, and serve as basic building blocks for proofs of B obligations translated by our tool.

\subsection{Encoding partial B operators}
A central challenge in this setting is the use of \emph{partial} B operators, meaning that they are only defined when some \emph{well-definedness} (WD) conditions are satisfied.
A typical example of such an operator is the minimum operator $\bmin{S}$, which when given a set $S$ returns its smallest element (w.r.t.\@ the ordering $\le$ on integers or reals), if it exists, and is undefined otherwise.
These partial operators are typically encoded using Hilbert's bounded choice operator $\epsilon\ x \in S.\ P$ which is undefined if no element of $S$ satisfy $P$.
The \emph{WD condition} of the corresponding operator is that $P$ is satisfied by (at least) an element of $S$.

Atelier B handles this partiality by generating the WD conditions of each partial operator used in a PO as side goals and assumes in the main goal that the partial operators are well-defined.
However, one must trust that these WD conditions actually correspond to the WD conditions that are expected from the context of those partial operators, and there is no clear dependency---even after inspecting the generated POG file---between the main goal and the WD side goals.
Furthermore, these WD conditions are only generated for the goal itself but not during proof steps.
This can lead to inconsistencies if the user is not careful enough for instance when instantiating quantified variables in the interactive prover.

Our approach in \barrel differs from Atelier B in that the dependency between the WD goals and the main goals is clear and explicit.
%
First, we do not rely on the WD conditions that are generated by Atelier B and instead generate our own to match the exact context in which they are inserted.
This is not necessarily true of the WD conditions generated by Atelier B since they undergo some simplification steps or do not match exactly our encoding of some predicates.
In practice, our tool generates WD side goals that are equivalent to the WD side goals generated by Atelier B.
%
Then, we take advantage of the dependent types of Lean to encode partial operators using \texttt{Classical.choose} (Hilbert's $\epsilon$ operator, but in Lean) which explicitly depends on a proof that the predicate is satisfied by at least one element\footnote{Lean has no built-in notion of partiality and must therefore exhibit WD conditions as explicit proof parameters of the relevant total functions.}.
This means that one cannot construct a term depending on a partial operator without providing a proof that it is well-defined.
The statement of this proof, which is the WD condition of the operator, is then generated as a side theorem (or a subgoal) which must be discharged for the main theorem to be fully proven, i.e.\@ not depend on the \texttt{sorryAx} axiom---the axiom that is introduced by admitted theorems.
To illustrate this use of \texttt{Classical.choose}, the encoding (and WD conditions) of $\bmin{S}$ and function application $\bapp{F}{x}$ are given in \cref{lst:min-fn-app}.

\begin{lstlisting}[label=lst:min-fn-app, caption={Encoding of the $\bmin{S}$ and $\bapp{F}{x}$ partial operators.}, float=t]
structure min.WD {Î±} [LinearOrder Î±] (S : Set Î±) : Prop where
  isBoundedBelow : âˆƒ x âˆˆ S, âˆ€ y âˆˆ S, x â‰¤ y

noncomputable 
abbrev min {Î±} [LinearOrder Î±] (S : Set Î±) (wd : min.WD S) : Î± :=
  Classical.choose wd.isBoundedBelow

structure app.WD {Î± Î²} (f : SetRel Î± Î²) (x : Î±) : Prop where
  isPartialFunction : f âˆˆ dom f  âŸ¶  ran f
  isInDomain : x âˆˆ dom f

noncomputable 
abbrev app {Î± Î²} (f : SetRel Î± Î²) (x : Î±) (wd : app.WD f x) : Î² :=
  Classical.choose wd.isInDomain
scoped notation:290 F:290 "(" x:min ")'" wd:300 => app F x wd
\end{lstlisting}

\subsection{Implementation and Automation}
\noindent\todo[Find a better title!]

\noindent\todo[Write about the implementation part]

\paragraph*{Proof automation}
\label{par:automation}
Before presenting the remaining goals to the user, \barrel runs a lightweight, predictable automation pass whose primary purpose is to discharge routine side conditions induced by our encoding of B partial operators.
Concretely, the tactic layer repeatedly applies potentially relevant lemmas---backtracking as needed---that relate WD subgoals and available hypotheses.
These helper lemmas provide definitional equations and rewriting/simplification facts for the B constructs supported by \barrel about sets, relations, functions, arithmetic and finiteness idioms, so that many generated WD goals reduce to elementary facts about membership, domain/range inclusion, finiteness, and order bounds and can be closed automatically.
We leverage Mathlib's features to tag helper lemmas with relevant categories and tap into its rich library of set-theoretic results to keep the tactic small and focused.

\paragraph*{A small library of B lemmas}
Beyond the core encoding of B primitives, \barrel comes with a curated---still small, but already well-furnished---library of theorems about built-in operators.
Its purpose is twofold:
\begin{enumerate}
  \item provide reusable WD facts that discharge the side-goals generated for partial operators;
  \item offer canonical rewrite lemmas that turn B-shaped expressions into ``Mathlib-friendly'' goals.
\end{enumerate}
For instance, in the arithmetic fragment used throughout our running examples, the library includes dedicated WD lemmas for the minimum operation, as shown in \cref{lst:min-wd-lemmas}, each of which being tagged with the relevant tag.

\begin{lstlisting}[language=lean, caption={Some WD lemmas about extrema in our B library.}, label=lst:min-wd-lemmas, float]
  -- choose amongst those
  theorem min.WF_singleton
  theorem min.WF_of_finite
  theorem min.WF_interval
\end{lstlisting}

The library also provides basic membership results about finite-sets and intervals; and in the same spirit, ``computational'' equalities are exposed as rewrite rules, again all tagged appropriately to be picked up by relevant automation, as shown in \cref{lst:finset-interval-lemmas}.

\begin{lstlisting}[language=lean, caption={Some membership lemmas about finite-sets and intervals in our B library.}, label=lst:finset-interval-lemmas, float]
  -- choose amongst those
  theorem FIN_1.singleton_mem
  theorem interval.FIN_1_mem
  theorem min.of_singleton
  theorem interval.min_eq
\end{lstlisting}

The remaining obligations---typically invariant preservation and refinement simulation goals---are left as interactive proof tasks, keeping the automation transparent and predictable while still removing most of the WD bookkeeping arising from B developments.